[{"title":"APK签名机制说明","url":"/2018/03/19/APK签名机制说明/","content":"\n#### 背景\n由于业务需求，我们需要统计用户下载安装apk的来源，所以针对不同的应用市场或活动页面，我们发布的apk都带了对应的渠道信息，针对apk携带对应的渠道信息，网上已经有很多成熟的方案了，例如使用gradle来构建不同的渠道包等方式。然而考虑到打包效率的问题，我们并没有使用gradle来构建多渠道的方式，而是使用[美团](https://tech.meituan.com/mt-apk-packaging.html)的自动化生成渠道包的方式来实现的。\n\n由于这种方式并不能适配APK Signature Scheme v2机制，所以我们的项目中一直都关闭了使用v2的签名机制。然后由于最近一些安全的问题，所以我们不得不在项目中开始使用v2机制来进行签名apk，虽然[美团](https://tech.meituan.com/android-apk-v2-signature-scheme.html)针对v2签名机制提供了另外的生成渠道包方案，但是还是想在使用之前，更多了解一下android的签名机制。\n<!-- more -->\n\n### 关于APP签名\nAPP签字在Android系统中有着极其重要的作用，主要体现在如下：\n1. 校验apk是否伪造或被修改过\n2. 升级APP时校验目标apk是否与原app一致\n3. 代码或数据共享，一个应用可以为另一个使用相同证书签名的应用程序公开自己的功能或数据\n\n#### APK格式\n​apk文件，本质上就是一个zip格式的文件：\n​![](/images/about_apk_signing/apk_file_format_1.jpg)<br/>\n​而apk签名，则是基于此文件格式，添加apk文件中部分数据的数字签名信息；而在检验的时候，读取该部分签名信息并对其所对应的部分数据进行校验。\n\n#### Zip文件格式\n因为apk本质就是一个zip格式的文件，所以，在开始了解apk的签名之前，有必要了解一下zip的文件格式：\n![](/images/about_apk_signing/zip_file_format_1.png)\n.ZIP文件格式总览：\n```\n[文件标头 1]\n[文件数据 1]\n[数据描述符记录 1]\n.\n.\n.\n[文件标头 n]\n[文件数据 n]\n[数据描述符记录 n]\n[归档解密标头]\n[归档额外数据记录]\n[中央目录结构]\n[中央目录记录的 Zip64 结尾]\n[中央目录定位器的 Zip64 结尾]\n[中央目录记录的结尾]\n```\n其中有几个数据在后续的漏洞和签名分析中，有重要作用，在这进行一下详细说明：\n**Local File Header:**\n```\n- A 文件标头 --------------------\n\n文件标头签名       4 字节 [开始 0] (0x04034b50)\n所需版本           2 字节 [开始 4]\n一般用途位标记     2 字节 [开始 6]\n压缩方法           2 字节 [开始 8] (8=DEFLATE; 0=UNCOMPRESSED)\n文件的最后修改时间 2 字节 [开始 10]\n文件的最后修改日期 2 字节 [开始 12]\ncrc-32             4 字节 [开始 14]\n压缩后的大小       4 字节 [开始 18]\n解压缩后的大小     4 字节 [开始 22]\n文件名长度         2 字节 [开始 26]\n额外字段长度       2 字节 [开始 28]\n\n文件名             变量\n额外字段           变量\n```\n**End of Central Directory**\n```\n- I 中央目录记录的结尾 --------------------\n\n中央目录记录签名                4 字节 [开始 0] (0x06054b50) 注：使用“冒泡”从文件尾追查上来，找到这个签名。\n磁盘编号                        2 字节 [开始 4]\n中央目录开始磁盘编号            2 字节 [开始 6]\n本磁盘上在中央目录里的入口总数  2 字节 [开始 8]\n中央目录里的入口总数            2 字节 [开始 10] 注：文件总数，文件夹也算一个文件。\n中央目录的大小                  4 字节 [开始 12]\n中央目录对第一张磁盘的偏移量    4 字节 [开始 16]\n.ZIP 文件注释长度               2 字节 [开始 20]\n.ZIP 文件注释                   变量   [开始 22]\n```\n而解析zip文件的过程，则是通过从文件尾部逆向查找End of Central Directory的起始标识，从而解析对应的Central Directory，进而解析zip里面的所有文件信息。\n\n#### APK Signature Scheme v1\n​v1 scheme是基于[jar签名](https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html)来实现，而jar的签名机制，则是往zip文件中，插入一个META-INFO文件夹，然后将所有与签名相关的信息都保存在这个文件夹下。同样，通过对比已签名和未签名apk解压后的META-INFO文件夹下的文件，以分析v1 scheme签名的实现原理：\n​![](/images/about_apk_signing/compare_apk_signed_unsign.jpg)\n相比未签名的apk，已签名的apk的META-INFO文件夹下，多了{name}.RSA和{name}.SF文件，根据[JAR文件格式描述](https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html)可知：\n* MANIFEST.MF 保存了apk中所有需要校验的文件所对应的摘要\n* {name}.SF 保存了MANIFEST.MF中所对应每块数据所对应的摘要\n* {name}.RSA 保存了对应非对称加密算法所使用的公钥和{name}.SF文件经过非对称加密后的密文\n\n<br/>以上三个文件的生成逻辑，都可以在`build/tools/signapk/src/com/android/signapk/SignApk.java`源码文件中找到。\n<br/>\n* MANIFEST.MF文件的生成，在的`addDigestsToManifest`方法中。签名工具会遍历apk文件中的所有文件（过滤其中的一些文件），并针对这些文件通过摘要算法生成摘要信息并base64编码之后保存在MANIFEST.MF文件中：\n![](/images/about_apk_signing/generate_manifest_file_1.jpg)\n<br/><br/>\n* {name}.SF文件的生成，则在`writeSignatureFile`方法中。签名工具会读取MANIFEST.MF文件中的所有section，然后针对每个section通过摘要算法生成摘要信息并base64编码之后保存在{name}.SF文件中，此处很容易让人误解{name}.SF文件中的内容是经过非对称加密之后所产生的，然而并非如此，该方法连加密所需要用到的公钥和私钥都没有被传入，只是针对每个section进行摘要并base64编码而已：\n![](/images/about_apk_signing/generate_name_sf_file_1.jpg)\n<br/><br/>\n* {name}.RSA文件的生成，在`writeSignatureBlock`方法中。该方法将生成的{name}.SF文件经过非对称加密生成密文之后，与公钥合并生成{name}.RSA文件：\n![](/images/about_apk_signing/generate_name_rsa_file_1.jpg)\n\n\n<br/>而在对apk进行验签的过程，则是与生成apk相反的过程，系统会先根据{name}.RSA中的公钥和密文，还原出原文并与{name}.SF对比，以验证{name}.SF文件是否被修改过，然后在根据MANIFEST.MF文件(*读取MANIFEST.MF的时候，**会根据MANIFEST.MF中section信息进行验证apk中的文件是否会修改过的***)中的section与{name}.SF文件中的section进行对比验证。\n<br/>由于v1签名不会对META-INFO文件夹内的文件进行校验，所以可以通过在META-INFO文件夹下添加文件以达到APK携带渠道等信息的目的。\n\n#### APK Signature Scheme v2\n鉴于APK Sinature Scheme v1存在安全漏洞，所以google推出了新的签名校验的方式：APK Signature Scheme v2。\nv2是针对整个文件进行签名校验的机制，所以具有更高的安全性和更好的校验速度。其实现机制在于，在ZIP 的Central Directory 部分前面插入一个APK Signature Block，如下图：\n![](/images/about_apk_signing/apk_before_after_signing.png)\n\n##### APK Signature Scheme v2 Signing Block\nSigning Block 格式如下：\n```\n[size of block]                         8 字节\n[length prefixed ID-values pairs]       8 字节 + 4 字节 + (length - 4)字节 (8字节的长度，标识后面这对id和value的长度)\n.\n.\n.\n[length prefixed ID-values pairs]\n[size of block]                         8 字节\n[magic]                                 16 字节，内容为\"APK Sig Block 42\"\n```\n而apk的签名校验信息(公钥及加密的密文)则是存在ID为`0x7109871a`的value中，所以获取apk签名校验信息的过程，其实就是查找Signing Block中id为`0x7109871a`的过程：\n![](/images/about_apk_signing/scheme_v2_find_signing_block_1.jpg)\n![](/images/about_apk_signing/scheme_v2_find_signing_block_2.png)\n而在查找签名校验信息的过程中，系统会过滤ID为其他值的键值对。\n\n##### APK Signature Scheme v2签名方式\nv2签名会计算除Signing Block之外的所有数据的摘要，然后使用非对称加密之后保存在Signing block中：\n![](/images/about_apk_signing/apk_integrity_protection_1.png)\n在对apk进行签名的时候，签名工具会将原的Central Directory前的数据(不包含signing block)、Central Directory和End of Central Directory分别进行分段并计算摘要(每段都分成1M大小的数据，然后计算`0xa5 + Chunk Lenght(4 byte) + Chunk`的摘要)，然后再针对计算出来的摘要数据(计算`0xa5 + Chunks Count(4 byte) + Chunks Digests`)再进行一次摘要计算，从而得到最终待加密的摘要数据，最后合并摘要加密后的数据和证书的公钥组成Signing Block。\n其中有个让人困惑的地方是，签名工具在Central Directory前面插入Signing Block之后，会导致End of Central Directory中保存的Central Directory offset变更(不然会破坏其原有的ZIP格式而导致无法解压出其中的文件)：\n![](/images/about_apk_signing/sign_apk_v2_change_cd_offset_1.jpg)\n那么这必然会导致后续验签的时候，根据End of Central Directory计算出来的摘要数据与之前不匹配。很多资料或者博文都没有提到这点是怎么解决的，甚至还有资料说Central Directory offset字段不参与计算摘要的，但是通过查看计算摘要信息的算法中，并没有对该字段进行特殊处理的：\n![](/images/about_apk_signing/sign_apk_v2_not_ignore_cd_offset_1.jpg)\n*其中contents数组对应上面的beforeCentralDir, centralDir 和 eocd*\n既然这个问题，在生成签名的时候没有绕过，那么只可能是在验签的时候进行绕过了。事实上，在验签的过程中，系统在获取到End of Central Directory数据之后，会先将Central Directory offset字段还原回没有Signing Block的时候Central Directory的offset(即Signing Block的起始位置):\n![](/images/about_apk_signing/sign_apk_v2_not_ignore_cd_offset_2.jpg)\n\n#### 关于APK Shgnature Scheme v1的漏洞\n##### “MasterKey”漏洞 & “Janus”漏洞 & “9950697”漏洞\n参考[独家分析：安卓“Janus”漏洞的产生原理及利用过程](https://zhuanlan.zhihu.com/p/31905112)\n\n#### APK Signature Scheme v2的不足\n\n#### 参考文献\n[1. Application Signing](https://source.android.com/security/apksigning/)\n[2. APK Signature Scheme v2](https://source.android.com/security/apksigning/v2)\n[3. APK Signature Scheme v1](https://source.android.com/security/apksigning/v2#v1-verification)\n[4. JAR File Specification](https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html)\n[5. Zip (file format)](https://en.wikipedia.org/wiki/Zip_&#40;file_format&#41;#Standardization)\n[6. .ZIP File Format Specification](https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt)\n\n[7. 美团Android自动化之旅—生成渠道包](https://tech.meituan.com/mt-apk-packaging.html)\n[8. 新一代开源Android渠道包生成工具Walle](https://tech.meituan.com/android-apk-v2-signature-scheme.html)\n[9. 独家分析：安卓“Janus”漏洞的产生原理及利用过程](https://zhuanlan.zhihu.com/p/31905112)\n","tags":["Sinature Scheme v2"],"categories":["Android"]},{"title":"基于HTTP报文分析HTTP协议","url":"/2017/12/20/基于HTTP报文分析HTTP协议/","content":"\n###  **关于HTTP**\n[HTTP](https://zh.wikipedia.org/zh-hans/超文本传输协议)（HyperText Transfer Protocol, 缩写：HTTP），是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是基于文本的协议，也就是说我们可以很直观的看到每个HTTP报文的相关内容，基于此前提，本文通过分析对应的HTTP报文来了解HTTP协议的相关信息。\n<!-- more -->\n#### **关于URI**\n在了解HTTP协议之前，有必要先了解一下URI，毕竟HTTP协议是基于URI来实现的。\n\n##### **URI定义**\n每个Web服务器资源都有一个名字，被成为**[URI](https://zh.wikipedia.org/wiki/统一资源标志符) (Uniform Resource Identifier)**，用于在世界范围内标识并定位信息资源。\n\n##### **关于URL**\n[URL (Uniform Resource Locator)](https://zh.wikipedia.org/wiki/统一资源定位符)是URI最常见的一种形式，用于描述一台特定服务器上某资源的特定位置，它可以明确的说明如何从一个精确、固定的位置获取资源。\n\n##### **URL的标准格式**\n大多数URL方案的URL语法都建立在由以下9部分构成的通用格式上：<br/>\n`<schema>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>`<br/>\n其中：<br/>\n\n|    组件    |                    描述                    |  默认值  |\n| :------: | :--------------------------------------: | :---: |\n|  schema  |            访问服务器获取资源时要使用哪种协议             |   无   |\n|   user   |              某些方案访问时所需要的用户名              |  匿名   |\n| password |              某些方案访问时所需要的密码               |   无   |\n|   host   |              资源服务器的主机名或这IP               |   无   |\n|   port   |               资源服务器所监听的端口号               | 与协议相关 |\n|   path   |          资源在服务器上的路径，使用/与前面组件隔开           |   无   |\n|  params  | 某些方案使用此组件来输入参数，参数为名/值对；可以包含多个参数字段，相互之间及与路径使用\";\"隔开 |   无   |\n|  query   |     某些方案使用此组件来传递参数，用\"?\"将其与URL的其余部分分隔     |   无   |\n|   frag   |      用来标识资源的某个片段，用\"#\"将其与URL的其余部分分隔       |   无   |\n\n<br/>*事实上，几乎没有哪个URL中包含了以上所有组件；其中最为重要的是schema、host、path。*\n\n例如：<br/>\n\nhttps://twitter.com/Jiasheng_Lee\nhttp://ljsalm089.github.io/git/2015/11/10/Android项目版本管理.html\n\n##### **URL encode**\n\n因一些协议在实现传输的过程中，会剥去一些特定的字符；且在使用URL的过程中，一些字符因有特殊的意义而被保留。为了避开这两种限制，人们设计了一种编码机制，通过“转义”来表示对应的非安全字符及关键字符。\n\n这种转义表示法包含一个\"%\"，后面跟随两个标识字符ASCII码的十六进制数。\n\n下表列出了保留及受限的字符:\n\n|       字符        |                 保留/受限                 |\n| :-------------: | :-----------------------------------: |\n|        %        |             保留作为编码字符的转义标志             |\n|        /        |           保留作为路径组件中分隔路径的定界符           |\n|        .        |              保留在路径组件中使用               |\n|       ..        |              保留在路径组件中使用               |\n|        #        |              保留作为分段定界符使用              |\n|        ?        |            保留作为查询字符串定界符使用             |\n|        ;        |              保留作为参数定界符使用              |\n|        :        |     保留作为协议、用户/密码，以及主机/端口组件的定界符使用      |\n|      $, +       |                  保留                   |\n|       @&=       |          在某些方案的上下文中有特殊的含义，保留          |\n|   {}\\｜\\^~[]'    |    由于各种传输Agent代理，比如各种网关的不安全处理，使用受限    |\n|       <>\"       |        不安全，这些字符在URL范围之外通常是有意义的        |\n| 0x00-0x1F, 0x7F | 受限，这些十六进制范围内的字符都在US-ASCII字符集的不可打印区间内  |\n|      >0x7F      | 受限，十六进制值在此范围内的字符都不在US-ASCII字符集的二进制范围内 |\n\n<br/>URL转义Demo：<br/>\nhttp://ljsalm089.github.io/git/2015/11/10/Android项目版本管理.html ——> http://ljsalm089.github.io/git/2015/11/10/Android%E9%A1%B9%E7%9B%AE%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86.html<br/>\n\n### **HTTP报文**\n\n所有的HTTP报文都可以分为两类：**请求报文**和**响应报文。\n\n#### **HTTP报文Demo**\nHTTP请求报文：<br/>\n![](/images/about_http/http_package_for_request.png)<br/>\nHTTP响应报文:<br/>\n![](/images/about_http/http_package_for_response.png)<br/>\nHTTP报文是简单的格式化数据块，它们由三部分组成:<br/>\n* 对报文进行描述的**起始行**<br/>\n* 包含属性的**首部(header)**块<br/>\n* 可选的、包含数据的**主体(body)**部分<br/>\n\n起始行和首部是有行分隔的ASCII文本，每行都以一个CRLF(回车换行)作为结束；报文的主体是一个可选的数据块，可包含文本或者二进制数据，也可为空。HTTP报文的首部以一行空行结束，即使没有头部和实体也应如此。\n\n#### **HTTP报文语法**\n\n##### **请求报文**\n\n以下是请求报文的格式：<br/>\n\n![](/images/about_http/http_package_request_format.png)<br/>\n\n* method: 请求的方式，一个单词，例如：GET、HEAD或POST。具体方式参看文章末尾对应表格。\n* request-url: 所请求的资源的路径\n* version: 报文所使用的HTTP版本，格式如：`HTTP/<主版本号>.<次版本号>`\n* header: 可以有0或多个首部，每个首部都包含一个名字，后面跟着\":\"，然后是一个可选的空格，接着是一个值，最后使用CRLF来作为一行的结束。首部是由一个CRLF来结束的。\n* entity-body: 实体的主体部分包含一个由任意数据组成的数据块。并非所有的报文都包含实体，有时报文只是以一个CRLF结束\n\n\n##### **响应报文**\n\n以下是响应报文的格式：<br/>\n\n![](/images/about_http/http_package_response_format.png)<br/>\n\n* status-code: 响应状态码，用来描述请求请求过程中发生的情况。对应状态码解析参看文章末尾对应表格。\n* reason-phrase： 状态码的可读描述。\n* header: 同请求报文。\n* entity-body: 同请求报文。\n\n\n关于HTTP报文格式的说明，则止于以上。而HTTP协议，则是基于此报文格式来进行实现并扩展的，而其中涉及到连接、代理、缓存、网关、隧道等，都是基于HTTP报文的header或者实体进行展开处理。\n\n\n常用HTTP请求方法：<br/>\n\n|   方法    |            描述            | 是否包含主体 |\n| :-----: | :----------------------: | :----: |\n|   GET   |        从服务器获取一份文档        |   N    |\n|  HEAD   |     只从服务器获取文档的header     |   N    |\n|  POST   |      向服务器发送需要处理的数据       |   Y    |\n|   PUT   |     将请求的body存储在服务器上      |   Y    |\n|  TRACE  | 对可能经过代理服务器传送到服务器上的报文进行追踪 |   N    |\n| OPTIONS |     决定可以在服务器上执行哪些方法      |   N    |\n| DELETE  |       从服务器上删除一份文档        |   N    |\n\n状态码分类<br/>\n\n|    范围     |   已定义范围   |  分类   |\n| :-------: | :-------: | :---: |\n| 100 ~ 199 | 100 ~ 101 | 信息提示  |\n| 200 ~ 299 | 200 ~ 206 |  成功   |\n| 300 ~ 399 | 300 ~ 305 |  重定向  |\n| 400 ~ 499 | 400 ~ 415 | 客户端错误 |\n| 500 ~ 599 | 500 ~ 505 | 服务器错误 |\n\n常用状态码<br/>\n\n| 状态码  |       原因短语        |         含义          |\n| :--: | :---------------: | :-----------------: |\n| 200  |        OK         |         成功          |\n| 401  | Unauthorized(未授权) |     需要输入用户名和密码      |\n| 404  |  Not Found(未找到)   | 服务器无法找到所请求的URL对应的资源 |\n\n**未完待续**\n","tags":["Charles"],"categories":["network"]},{"title":"关于Android APP Hot Fix－Nuwa实现原理分析","url":"/2016/11/29/Android_Nuwa实现原理分析/","content":"\n## 关于Nuwa\nNuwa是由腾讯QQ空间团队实现的为Android APP进行紧急热修复方案的实现，该方案基于Android dex分包方案。\n\n## Nuwa的Hot Fix原理介绍\nNuwa通过将有问题的Class打包成Dex文件，APP动态加载对应的Dex文件中的Class来覆盖原来的Class文件，从而实现Hot Fix。\n<!-- more -->\n\n## Nuwa实现分析\nNuwa主要包含两个项目:[Nuwa](https://github.com/jasonross/Nuwa)(Android Library project)和[NuwaGradle](https://github.com/jasonross/NuwaGradle)(Gradle Plugin)，其作用分别如下.<br/>\nNuwa: Android Library project。<br/>\nNuwaGradle: Gradle Plugin project。<br/>\n\nNuwa，作为Android Library project，其主要作用是为APP提供加载Dex文件的功能以及提供Hack.class类。加载Dex文件的功能主要在如下类中实现：<br/><br/>\nNuwa.java 提供初始化及加载Patch(dex or apk)文件的方法，初始化方法中将存在asset中的hack.apk copy到app的内部储存文件夹中，并加载hack.apk，为app的所有类(not include Application class)提供Hack类支持(后面叙述Hack类的作用)。\n\n    public static void init(Context context) {\n        File dexDir = new File(context.getFilesDir(), DEX_DIR);\n        dexDir.mkdir();\n\n        String dexPath = null;\n        try {\n            dexPath = AssetUtils.copyAsset(context, HACK_DEX, dexDir);\n        } catch (IOException e) {\n            Log.e(TAG, \"copy \" + HACK_DEX + \" failed\");\n            e.printStackTrace();\n        }\n\n        loadPatch(context, dexPath);\n    }\n\n    public static void loadPatch(Context context, String dexPath) {\n        if (context == null) {\n            Log.e(TAG, \"context is null\");\n            return;\n        }\n        if (!new File(dexPath).exists()) {\n            Log.e(TAG, dexPath + \" is null\");\n            return;\n        }\n        File dexOptDir = new File(context.getFilesDir(), DEX_OPT_DIR);\n        dexOptDir.mkdir();\n        try {\n            DexUtils.injectDexAtFirst(dexPath, dexOptDir.getAbsolutePath());\n        } catch (Exception e) {\n            Log.e(TAG, \"inject \" + dexPath + \" failed\");\n            e.printStackTrace();\n        }\n    }\n\nDexUtils.java 主要提供Patch(dex/apk)的加载方法。在Android中，使用BaseDexClassLoader来加载dex/apk文件，而BaseDexClassLoader使用DexPathList类型的成员变量pathList来存储所有的dex信息，ClassLoader findClass 的过程就是遍历DexPathList中的数组成员变量dexElements来查找对应的Class。BaseDexClassLoader有两个继承类：DexClassLoader和PathClassLoader，PathClassLoader主要用于加载已经进行optdex优化后的dex，而DexClassLoader则用于加载未进行optdex优化的dex/apk。Android默认的classloader是PathClassLoader。关于ClassLoader的更多介绍，请参考[Java ClassLoader基础](http://www.trinea.cn/android/java-loader-common-class/)\n\n\t/**\n\t * 加载dex并插入到PathClassLoader的成员变量pathList中\n\t */\n\tpublic static void injectDexAtFirst(String dexPath, String defaultDexOptPath) throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException {\n        DexClassLoader dexClassLoader = new DexClassLoader(dexPath, defaultDexOptPath, dexPath, getPathClassLoader());\n        Object baseDexElements = getDexElements(getPathList(getPathClassLoader()));\n        Object newDexElements = getDexElements(getPathList(dexClassLoader));\n        Object allDexElements = combineArray(newDexElements, baseDexElements);\n        Object pathList = getPathList(getPathClassLoader());\n        // 通过反射来设置PathClassLoader的pathList的dexElements\n        ReflectionUtils.setField(pathList, pathList.getClass(), \"dexElements\", allDexElements);\n    }\n\n\t/**\n\t * 获取Android默认的PathClassLoader\n\t */\n    private static PathClassLoader getPathClassLoader() {\n        PathClassLoader pathClassLoader = (PathClassLoader) DexUtils.class.getClassLoader();\n        return pathClassLoader;\n    }\n\n\t/**\n\t * 获取DexPathList对象中获取其dexElements成员变量\n\t */\n    private static Object getDexElements(Object paramObject)\n            throws IllegalArgumentException, NoSuchFieldException, IllegalAccessException {\n        return ReflectionUtils.getField(paramObject, paramObject.getClass(), \"dexElements\");\n    }\n\n\t/**\n\t * 从BaseDexClassLoader对象中获取其pathList成员变量\n\t */\n    private static Object getPathList(Object baseDexClassLoader)\n            throws IllegalArgumentException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException {\n        return ReflectionUtils.getField(baseDexClassLoader, Class.forName(\"dalvik.system.BaseDexClassLoader\"), \"pathList\");\n    }\n\n\t/**\n\t * 合并两个dexElements列表\n\t */\n    private static Object combineArray(Object firstArray, Object secondArray) {\n        Class<?> localClass = firstArray.getClass().getComponentType();\n        int firstArrayLength = Array.getLength(firstArray);\n        int allLength = firstArrayLength + Array.getLength(secondArray);\n        Object result = Array.newInstance(localClass, allLength);\n        for (int k = 0; k < allLength; ++k) {\n            if (k < firstArrayLength) {\n                Array.set(result, k, Array.get(firstArray, k));\n            } else {\n                Array.set(result, k, Array.get(secondArray, k - firstArrayLength));\n            }\n        }\n        return result;\n    }\n\n按照如上的原理，那么使用一个Android Library就可以实现Hot Fix功能，那么为啥Nuwa还要提供一个Gradle Plugin来做支持？<br/>\n原来，apk在安装之时，classes.dex会被虚拟机(dexopt)优化称为odex文件，然后才拿去执行，而虚拟机在启动的时候，包含一项verify的选项，该选项致使虚拟机对class进行校验，如果校验成功，对应的类会被打上CLASS_ISPREVERIFIED的标志，而被打上该标示的class，在查找其所引用的class时，会进行判断该class与被引用的class是否在同一个dex文件中，如果不是，则会抛出\"Class resolved by unexpected DEX\"的IllegalAccessException。由于Patch中的class用于覆盖classes.dex重的类，所以会导致部分类在classes.dex文件中，部分在patch.dex文件中，故会出现如上错误。<br/><br/>\n而解决此问题的方法就是防止class被打上CLASS_ISPREVERIFIED的标志，因此需在虚拟机对class进行校验时返回false，虚拟机对class的校验如下：<br/><br/>\n![此代码在DexVerify.cpp中](/images/nuwa/code_1.jpeg)\n<br/><br/>\n1. 验证class->directMethods方法，directMethods包括：static方法、private方法、构造函数<br/>\n2. 验证class->virtualMethods方法。<br/>\n概括就是如果以上方法中直接引用到的class(第一层级关系，不会进行递归搜索)和class都在同一个dex中的话，那么这个class就不会被打上CLASS_ISPREVERIFIED标志<br/><br/>\nNuwaGradle这个Gradle Pligin project就是为了实现这个目的的。<br/><br/>\n\nNuwaGradle，使用Groovy实现的Gradle plugin项目，其主要作用有：1. gradle task插入，2. java字节码级别的代码插入， 3. 记录编译后各class文件的hash值， 4. 根据hash变化与否来进行打包patch.jar\n查看一个标准Android Project的gradle task：\n\n\t$ gradle -q tasks --all\n\t...\n\tapp:assembleRelease - Assembles all Release builds. [app:compileReleaseSources]\n    app:dexRelease\n    app:packageRelease\n    app:preDexRelease\n    ...\n    app:compileReleaseSources\n    app:checkReleaseManifest\n    app:compileReleaseAidl\n    app:compileReleaseJavaWithJavac\n    app:compileReleaseNdk\n    app:compileReleaseRenderscript\n    app:generateReleaseAssets\n    app:generateReleaseBuildConfig\n    app:generateReleaseResValues\n    app:generateReleaseResources\n    app:generateReleaseSources\n    app:mergeReleaseAssets\n    app:mergeReleaseResources\n    app:preBuild\n    app:preDebugBuild\n    app:preReleaseBuild\n    app:prepareComAndroidSupportAppcompatV72220Library - Prepare com.android.support:appcompat-v7:22.2.0\n    app:prepareComAndroidSupportDesign2220Library - Prepare com.android.support:design:22.2.0\n    app:prepareComAndroidSupportSupportV42220Library - Prepare com.android.support:support-v4:22.2.0\n    app:prepareReleaseDependencies\n    app:processReleaseJavaRes\n    app:processReleaseManifest\n    app:processReleaseResources\n    ...\n\n根据输出可知，在构建Android Project的过程中，存在dex\\*\\* 和preDex\\*\\* 任务。而NuwaGradle则在对应的preDex\\*\\* Task前插入修改字节码的任务及在dex\\*\\*任务前把有与上一版本相比有修改的class文件提取到另外的文件夹并打包成Patch文件用于发布。\n\n\t...\n\tif (preDexTask) {\n\t\t// 定义在preDex** 任务之前插入的任务名为nuwaJarBeforePreDex**\n\t\tdef nuwaJarBeforePreDex = \"nuwaJarBeforePreDex${variant.name.capitalize()}\"\n\t\t// 定义任务nuwaJarBeforePreDex** 所执行的动作\n\t\tproject.task(nuwaJarBeforePreDex) << {\n\t\t\tSet<File> inputFiles = preDexTask.inputs.files.files\n\t\t\tinputFiles.each { inputFile ->\n\t\t\t\tdef path = inputFile.absolutePath\n\t\t\t\tif (NuwaProcessor.shouldProcessPreDexJar(path)) {\n\t\t\t\t\t// 对Jar文件中的class进行代码插入\n\t\t\t\t\tNuwaProcessor.processJar(hashFile, inputFile, patchDir, hashMap, includePackage, excludeClass)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 修改preDex** 与nuwaJarBeforePreDex** 任务的依赖顺序\n\t\tdef nuwaJarBeforePreDexTask = project.tasks[nuwaJarBeforePreDex]\n\t\tnuwaJarBeforePreDexTask.dependsOn preDexTask.taskDependencies.getDependencies(preDexTask)\n\t\tpreDexTask.dependsOn nuwaJarBeforePreDexTask\n\n\t\t// nuwaJarBeforePreDex** 之前执行一些初始化动作\n\t\tnuwaJarBeforePreDexTask.doFirst(nuwaPrepareClosure)\n\n\t\t// 定义在dex** 任务之前插入的任务名为nuwaClassBeforeDex**\n\t\tdef nuwaClassBeforeDex = \"nuwaClassBeforeDex${variant.name.capitalize()}\"\n\t\t// 定义任务nuwaClassBeforeDex** 所执行的动作\n\t\tproject.task(nuwaClassBeforeDex) << {\n\t\t\tSet<File> inputFiles = dexTask.inputs.files.files\n\t\t        inputFiles.each { inputFile ->\n\t        \t\tdef path = inputFile.absolutePath\n\t        \t\t// 对非R及BuildConfig类进行代码插入\n\t        \t\tif (path.endsWith(\".class\") && !path.contains(\"/R\\$\") && !path.endsWith(\"/R.class\") && !path.endsWith(\"/BuildConfig.class\")) {\n\t        \t\t\tif (NuwaSetUtils.isIncluded(path, includePackage)) {\n\t                \t\t\tif (!NuwaSetUtils.isExcluded(path, excludeClass)) {\n\t                        \t\t\tdef bytes = NuwaProcessor.processClass(inputFile)\n\t\t\t                          \tpath = path.split(\"${dirName}/\")[1]\n\t        \t\t                   \tdef hash = DigestUtils.shaHex(bytes)\n\t                \t\t           \thashFile.append(NuwaMapUtils.format(path, hash))\n\t                                \t// 判断此class的hash知否有变化，有的话则将该class拷贝至patch的文件夹\n\t\t\t\t\t\t\t\t\t\tif (NuwaMapUtils.notSame(hashMap, path, hash)) {\t                                \t\t\t\n\t\t\t\t\t\t\t\t\t\t\tNuwaFileUtils.copyBytesToFile(inputFile.bytes, NuwaFileUtils.touchFile(patchDir, path))\n\t                       \t\t\t\t}\n\t\t              \t\t\t}\n\t        \t    \t}\n\t        \t\t}\n\t        \t}\n\t        }\n\t        // 修改dex** 与nuwaClassBeforeDex** 任务的依赖顺序\n\t        def nuwaClassBeforeDexTask = project.tasks[nuwaClassBeforeDex]\n\t        nuwaClassBeforeDexTask.dependsOn dexTask.taskDependencies.getDependencies(dexTask)\n\t        dexTask.dependsOn nuwaClassBeforeDexTask\n\n\t\t\t// 将保存class hash的map文件copy到其他目录\n\t        nuwaClassBeforeDexTask.doLast(copyMappingClosure)\n\n\t        nuwaPatchTask.dependsOn nuwaClassBeforeDexTask\n\t        beforeDexTasks.add(nuwaClassBeforeDexTask)\n\t} else {\n\t\t...\n\t}\n\nNuwaGradle使用的是javaassist库来进行字节码插入的, 对Jar文件的代码注入操作：\n\n\tpublic static processJar(File hashFile, File jarFile, File patchDir, Map map, HashSet<String> includePackage, HashSet<String> excludeClass) {\n\t\tif (jarFile) {\n\t\t\t// 创建tmp 的jar文件\n\t\t\tdef optJar = new File(jarFile.getParent(), jarFile.name + \".opt\")\n\n\t\t    def file = new JarFile(jarFile);\n\t        Enumeration enumeration = file.entries();\n\t\t    JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(optJar));\n\n\t\t    while (enumeration.hasMoreElements()) {\n\t\t    \t// 读取jar文件中的每个类\n\t\t        JarEntry jarEntry = (JarEntry) enumeration.nextElement();\n\t\t        String entryName = jarEntry.getName();\n\t\t        ZipEntry zipEntry = new ZipEntry(entryName);\n\n\t\t        InputStream inputStream = file.getInputStream(jarEntry);\n\t\t       \tjarOutputStream.putNextEntry(zipEntry);\n\t\t\t\t// 判断是否需要注入代码\n\t           \tif (shouldProcessClassInJar(entryName, includePackage, excludeClass)) {\n\t           \t\t// 代码注入\n\t\t\t        def bytes = referHackWhenInit(inputStream);\n\t\t\t        // 写入到tmp jar文件中\n\t\t           \tjarOutputStream.write(bytes);\n\n\t               \tdef hash = DigestUtils.shaHex(bytes)\n\t\t\t\t    hashFile.append(NuwaMapUtils.format(entryName, hash))\n\t\t\t\t\t// 判断是否需要打包进patch\n\t\t\t        if (NuwaMapUtils.notSame(map, entryName, hash)) {\n\t\t                NuwaFileUtils.copyBytesToFile(bytes, NuwaFileUtils.touchFile(patchDir, entryName))\n\t                }\n\t\t        } else {\n\t\t\t\t\tjarOutputStream.write(IOUtils.toByteArray(inputStream));\n\t\t\t    }\n\t\t        jarOutputStream.closeEntry();\n\t        }\n\t\t\tjarOutputStream.close();\n\t\t    file.close();\n\n\t        if (jarFile.exists()) {\n\t\t        jarFile.delete()\n\t        }\n\t        // 覆盖原jar文件\n\t\t\toptJar.renameTo(jarFile)\n\t\t}\n\t}\n\n对class文件的代码注入操作：\n\n\tpublic static byte[] processClass(File file) {\n\t\tdef optClass = new File(file.getParent(), file.name + \".opt\")\n\n\t    FileInputStream inputStream = new FileInputStream(file);\n\t    FileOutputStream outputStream = new FileOutputStream(optClass)\n\t\t// 代码注入\n\t    def bytes = referHackWhenInit(inputStream);\n\t    outputStream.write(bytes)\n\t    inputStream.close()\n\t    outputStream.close()\n\t\tif (file.exists()) {\n\t        file.delete()\n\t\t}\n\t\toptClass.renameTo(file)\n\t\treturn bytes\n\t}\n\n\tprivate static byte[] referHackWhenInit(InputStream inputStream) {\n        ClassReader cr = new ClassReader(inputStream);\n        ClassWriter cw = new ClassWriter(cr, 0);\n        ClassVisitor cv = new ClassVisitor(Opcodes.ASM4, cw) {\n            @Override\n            public MethodVisitor visitMethod(int access, String name, String desc,\n                                             String signature, String[] exceptions) {\n\n                MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n                mv = new MethodVisitor(Opcodes.ASM4, mv) {\n                    @Override\n                    void visitInsn(int opcode) {\n                    \t// Java编译器在为它编译的每个类都至少生成一个实例化方法，即<init>方法。\n                    \t// 在类的实例化方法<init>中，给其添加一个Hack类型的常量\n\t\t\t\t\t\tif (\"<init>\".equals(name) && opcode == Opcodes.RETURN) {\n\t\t\t\t\t\t\tsuper.visitLdcInsn(Type.getType(\"Lcn/jiajixin/nuwa/Hack;\"));\n\t\t\t\t\t\t}\n                       super.visitInsn(opcode);\n                    }\n                }\n                return mv;\n            }\n\n        };\n        cr.accept(cv, 0);\n        return cw.toByteArray();\n    }\n\n如此则可避免所有的类被打上CLASS_ISPREVERIFIED标志，即class调用不同dex文件中的class也不会出错(PS:Application不应该被注入Hack类型常量，因为Hack.apk是在Application的attachBaseContext方法中加载，而在构造方法就引用了Hack类，因此会抛出异常)。\n\n## 总结\n\n## 遇到的坑\n1. <big>**使用了Nuwa之后，执行gradle clean && gradle build --info 命令会出现一下错误：**</big><br/>\n:app:nuwaJarBeforeDex\\*\\*\\*Release (Thread[Daemon worker,5,main]) completed. Took 0.011 secs.<br/><br/>\nFAILURE: Build failed with an exception.<br/><br/>\n\\* What went wrong:<br/>\nExecution failed for task ':app:nuwaJarBeforeDex\\*\\*\\*Release'.<br/>\n\\> $(ProjectPath)/app/build/intermediates/classes-proguard/\\*\\*\\*/release/classes.jar (No such file or directory)<br/><br/>\n出错原因：在VIPME项目中，针对debug和release的构建使用了不同的规则，为方便开发人员调试，在debug的构建规则中未打开代码混淆，而在release的规则重则打开了代码混淆，而使用gradle build进行构建的时候，是同时构建debug和release的版本。<br/>\n通过查看gradle build | grep \":\\*:\\*\"的输出：\n\n\t\t...\n\t\t:facebook:compileReleaseJavaWithJavac\n\t\t:facebook:extractReleaseAnnotations\n\t\t:facebook:mergeReleaseProguardFiles UP-TO-DATE\n\t\t:facebook:packageReleaseJar\n\t\t:facebook:compileReleaseNdk UP-TO-DATE\n\t\t:facebook:packageReleaseJniLibs UP-TO-DATE\n\t\t:facebook:packageReleaseLocalJar UP-TO-DATE\n\t\t:facebook:packageReleaseRenderscript UP-TO-DATE\n\t\t:facebook:packageReleaseResources\n\t\t:facebook:bundleRelease\n\t\t:app:prepareCnJiajixinNuwaNuwa100Library\n\t\t:app:prepareComAndroidSupportAppcompatV72220Library\n\t\t:app:prepareComAndroidSupportDesign2220Library\n\t\t:app:prepareComAndroidSupportRecyclerviewV72220Library\n\t\t:app:prepareComAndroidSupportSupportV42221Library\n\t\t:app:prepareComFacebookAndroidFacebook451Library\n\t\t:app:prepareComGoogleAndroidGmsPlayServicesAnalytics780Library\n\t\t:app:prepareComGoogleAndroidGmsPlayServicesBase780Library\n\t\t:app:prepareComGoogleAndroidGmsPlayServicesGcm780Library\n\t\t:app:prepareComTwitterSdkAndroidTweetComposer100Library\n\t\t:app:prepareComTwitterSdkAndroidTwitterCore160Library\n\t\t:app:prepareIoFabricSdkAndroidFabric136Library\n\t\t:app:prepareVipmeAndroidViewPagerIndicatorUnspecifiedLibrary\n\t\t:app:prepareOfficialDebugDependencies\n\t\t:app:compileOfficialDebugAidl\n\t\t:app:compileOfficialDebugRenderscript\n\t\t:app:generateOfficialDebugBuildConfig\n\t\t:app:generateOfficialDebugAssets UP-TO-DATE\n\t\t:app:mergeOfficialDebugAssets\n\t\t:app:generateOfficialDebugResValues\n\t\t:app:processOfficialDebugGoogleServices\n\t\t...\n\t\t:app:preDexOfficialDebug\n\t\t:app:nuwaClassBeforeDexOfficialDebug\n\t\t:app:dexOfficialDebug\n\t\t:app:validateDebugSigning\n\t\t:app:packageOfficialDebug\n\t\t:app:assembleOfficialDebug\n\t\t:app:assembleDebug\n\t\t:app:checkOfficialReleaseManifest\n\t\t:app:prepareOfficialReleaseDependencies\n\t\t:app:compileOfficialReleaseAidl\n\t\t:app:compileOfficialReleaseRenderscript\n\t\t:app:generateOfficialReleaseBuildConfig\n\t\t:app:generateOfficialReleaseAssets UP-TO-DATE\n\t\t:app:mergeOfficialReleaseAssets\n\t\t:app:generateOfficialReleaseResValues\n\t\t:app:processOfficialReleaseGoogleServices\n\t\t:app:generateOfficialReleaseResources\n\t\t...\n\n可知gradle对第三方依赖库项目(如VIPME所依赖的facebook和viewpagerindicator)的处理在是在所有的debugtask之前，而debug 的所有task又在release task之前，在app/build/intermediates/exploded-aar/文件夹中查看到，gradle对第三方依赖库处理的输出文件并没有对debug和release进行分开存放。<br/>\n同时，在build的过程中，混淆过程输出很多warning信息：\n\n\t\t:app:proguardOfficialRelease\n\t\t...\n\t\tWarning: com.facebook.AccessTokenManager$1: can't find referenced class cn.jiajixin.nuwa.Hack\n\t\tWarning: com.facebook.AccessTokenManager$2: can't find referenced class cn.jiajixin.nuwa.Hack\n\t\tWarning: com.facebook.AccessTokenManager$3: can't find referenced class cn.jiajixin.nuwa.Hack\n\t\tWarning: com.facebook.AccessTokenManager$4: can't find referenced class cn.jiajixin.nuwa.Hack\n\t\tWarning: com.facebook.AccessTokenManager$RefreshResult: can't find referenced class cn.jiajixin.nuwa.Hack\n\t\tWarning: com.facebook.AccessTokenSource: can't find referenced class cn.jiajixin.nuwa.Hack\n\t\tWarning: com.facebook.AccessTokenTracker: can't find referenced class cn.jiajixin.nuwa.Hack\n\t\tWarning: com.facebook.AccessTokenTracker$CurrentAccessTokenBroadcastReceiver: can't find referenced class cn.jiajixin.nuwa.Hack\n\t\tWarning: com.facebook.BuildConfig: can't find referenced class cn.jiajixin.nuwa.Hack\n\t\tWarning: com.facebook.CallbackManager$Factory: can't find referenced class cn.jiajixin.nuwa.Hack\n\t\tWarning: com.facebook.FacebookActivity: can't find referenced class cn.jiajixin.nuwa.Hack\n\t\t...\n\n由以上错误信息可知，release的proguard task失败导致未输出对应的class文件，而使app:nuwaJarBeforeDex task缺失输入文件而失败。但是NuwaGradle 是在preDex** task之前也就是proguard之后才注入Hack代码的，怎么会在proguard之前就已经有Hack了呢？猜测是debug和release都使用了同一份的第三方依赖库build输出的产物，而在debug 的proguard task已经对第三方依赖库的代码进行了注入，所以导致release proguard task运行失败。<br/>\n于是提取app/build/intermediates/exploded-aar/文件夹中facebook的classes.jar文件重命名为classes.zip并解压出来，提取其中的某个类\\*\\*\\*.class并对其反编译所得：<br/>\n\n\t$javap -v ***.class | grep Hack\n\t  #803 = Utf8               cn/jiajixin/nuwa/Hack\n\t  #804 = Class              #803          //  cn/jiajixin/nuwa/Hack\n\t  6: ldc_w         #804                // class cn/jiajixin/nuwa/Hack\n           9: ldc_w         #804                // class cn/jiajixin/nuwa/Hack\n          85: ldc_w         #804                // class cn/jiajixin/nuwa/Hack\n         552: ldc_w         #804                // class cn/jiajixin/nuwa/Hack\n\n由此证明debug和release使用相同的第三方依赖库产物来进行下一步的动作从而导致出现以上的错误。<br/>\n<br/>\n<big>*解决方法：*</big><br/>\n1. 使用gradle assembleRelease 命令只针对release进行构建 (推荐)；<br/>\n2. 打开debug的混淆（由于debug的task中已对第三方依赖库的产物jar进行了混淆，所以release的时候不会再次混淆）。<br/>\n\n(Done)\n","tags":["DexClassLoader"],"categories":["Android"]},{"title":"Android项目版本管理","url":"/2015/11/10/Android项目版本管理/","content":"\n### remote 分支管理\n\n1. 主分支master<br/>\n\t代码库有且只有一个master分支，用于保存正式版本对应的tag，并不用于version的发布。<br/>\n\t![](http://beekka.com/blog/201207/bg2012070503.png)\n<!-- more -->\n\n2. 开发分支dev<br/>\n\tremote端必须存在一个dev分支，主要用于项目功能的开发以及多个开发者之间代码的同步。另，不允许直接将dev分支的代码merge到master分支上。<br/>\n\n3. 测试分支Pre-Release<br/>\n\tremote端在适当的时候应该存在一个Pre-Release分支，其主要功能是打上tag以提交到测试组进行测试、测试结果bug的修复以及测试通过之后的version的发布。dev、Pre-Release、master分支关系如下：<br/>\n\t![](/images/android_version_control/dev-Pre_Release-master.png)\n\t<br/>\n\t当某一版本的功能开发完毕时，由dev分支checkout出Pre-Release分支，并打上tag提交到测试组进行测试，tag的格式为：TEST-$(VersionName)-$(TestTime)，其中VersionName为版本名，TestTime为该版本的第几次测试，测试的tag由指定的一位负责人进行标示。当一轮测试完成之后，开发者在Pre-release分支进行bug的修复。修复完bug之后负责人打上对应tag并提交到测试组进行新一轮的测试，并将此分支merge到dev分支。当该版本的测试通过之后，在对应的tag上打出release的包进行线上验证，只有线上验证通过之后，才允许将Pre-Release分支的代码merge到master分支。<br/>\n\t<br/>\n\t**注意：将Pre-Release分支的代码merge到master的时候，需添加--no-ff参数，以在master分支生成一个commit；当一个版本的发布之后，可以将remote端对应的Pre-Release分支删除。**<br/>\n\n4. 修复分支fixbug/hotfix<br/>\n\t当项目发布之后，如果发现某个version有bug，则在master对应的tag上checkout出fixbug/hotfix分支来进行bug修复，fixbug/fotfix分支本质上跟Pre-Release分支类似，需要修复bug之后打对应的tag提交到测试组，通过测试之后根据情况打出version或patch。fixbug/hotfix与dev和master分支的关系如下：<br/>\n\t![](/images/android_version_control/hotfix-dev-master.png)\n\t<br/>\n\tfixbug/hotfix分支的最终是否删除也需要视情况而定:<br/>\n\ta. 如果在该version后续的version中都存在该bug，但是并不影响项目的主流程，则可以将该分支的提交cherry-pick到dev分支，并将该分支merge到master以发布一个小版本的更新，最后可删掉对应的fixbug分支。<br/>\n\tb. 如果在该version后续的version中都存在该bug，且影响到项目的主流程，则应该将该分支的提交cherry-pick到dev，并合并代码到master，同时根据该hotfix分支打出相应的patch进行发布，以及发布对应版本更新，而对应的hotfix分支，则不能删除。\n\tc. 如果只是某个旧版本存在该bug，则且影响到主流程，则应该根据hotfix分支打出对应的patch进行发布，以及对应的hotfix分支不能删除。<br/>\n\n### local 分支管理\n\n1. 主分支master<br/>\n\t同remote端master分支。<br/>\n\n2. 开发分支dev<br/>\n\t同remote端dev分支。<br/>\n\n3. 测试分支Pre-Release<br/>\n\t同remote端Pre-Release分支。<br/>\n\n4. 修复分支fixbug/hotfix<br/>\n\t同remote端fixbug/hotfix分支。<br/>\n\n5. 功能实现分支feature<br/>\n\t该分支主要用于开发某类功能时使用，由dev分支checkout出来，在完成了该类功能的开发之后，将该分支merge到dev分支，并将该分支删除。<br>\n\t![](/images/android_version_control/feature-dev.png)\n\t**注意：原则上不允许将feature分支push到remote，除非某个feature是由多人共同开发；另外，将feature分支merge到dev的时候请尽量添加--no-ff参数，以在dev分支生成一个commit。**<br/>\n\n### git相关参数使用\n1. merge的 --no-ff参数<br/>\n\t默认情况下，git之行“快进式合并”(fast-forward merge)，如果子分支从父分支之checkout出来之后当前分支(父or子)没有做任何修改，此时合并父子分支的时候，git会将当前分支直接指向另一分支的最新提交处。此方式并不能很好的保证版本演进的清晰，因此建议在merge的时候添加上--no-ff参数，此方式能在merge之后，在当前分支生成一个新节点。如图示：<br/>\n\t![](/images/android_version_control/diff-with-or-no-__no_ff.png)\n\t<br/>\n2. rebase的 -i参数<br/>\n\t当feature分支或fixbug分支完成之后，合并到dev分支时可能不希望生成那么多个commit，那么则可使用git rebase命令并添加 -i 参数，详细说明和使用可参考附录中《Git使用规范流程》。\n\n### 附录\n1. [《Git分支管理策略》](http://www.ruanyifeng.com/blog/2012/07/git.html)<br/>\n2. [《Git使用规范流程》](http://www.ruanyifeng.com/blog/2015/08/git-use-process.html)<br/>\n\n(Done)\n","tags":["git"],"categories":["git"]},{"title":"簡單Git服務器的架設與ssh安全驗證","url":"/2014/05/16/简单Git服务器的架设与ssh安全验证/","content":"![](/images/git_ssh/Document-page-001.jpg)\n<!-- more -->\n![](/images/git_ssh/Document-page-002.jpg)\n![](/images/git_ssh/Document-page-003.jpg)\n![](/images/git_ssh/Document-page-004.jpg)\n![](/images/git_ssh/Document-page-005.jpg)\n![](/images/git_ssh/Document-page-006.jpg)\n(Done)\n","tags":["ssh"],"categories":["git"]}]